/* *	ParallaxRFIDReader - version 0.2 - 2007-05-24**	Revision History:*	version 0.2 - 2007-05-02**	Adam Hoyle and Alias Cummins (www.dotankstudios.com / www.proalias.com)**-----------------------------------------------------------------------------**	LICENCE**   This library is free software; you can redistribute it and/or modify it *	under the terms of the GNU Lesser General Public License *	as published by the Free Software Foundation; either version 2.1 of the License*	*   You should have received a copy of the GNU Lesser General Public License along with this library;*   Alternatively you can find it here http://www.gnu.org/licenses/lgpl.html*    *   Brief Explanation of the Licence:*   - you can you use, redistribute, modify this software for free,*	- you can put it into commercial projects*   - but if you modify/enhance this Library you should release it under the same licence or alternatively under the GPL licence*   - in all cases you should also credit the original author and all contributors** *-----------------------------------------------------------------------------**/package com.dotankstudios.arduino {import flash.net.Socket;import flash.events.ProgressEvent;//import net.eriksjodin.arduino.ParallaxRFIDEvent;import com.dotankstudios.arduino.RFIDEvent;public class RFIDReader extends Socket {			private var _host			: String  = "127.0.0.1"; // Host name or IP address	private var _port			: uint  = 5331;		 	 // Read the config file of the socket server for this one		// data processing varaibles	private var waitForData 	: uint = 0;		// data 	private var tag				: String = new String();	private var _readingArray	: Array		//---------------------------------------		//	CONSTRUCTOR		//---------------------------------------		public function RFIDReader(port, host) {			// initialize			super();									// check if the selected port is correct or set default			if ((_port < 1024) || (_port > 65535)) {				trace("** ParallaxRFIDReader ** Port must be from 1024 to 65535!")					} else {				_port = port;			}						// autoconnect			try{				connect(_host,_port);			}catch(e:Error){				trace("RFIDReader.RFIDReader("+port+","+ host+")");				trace("RFIDReader.RFIDReader::e.type="+e.errorID);				trace("RFIDReader.RFIDReader::e.message="+e.message);				}						// listen for events			addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler, false, 0, true);						seekForTag();			_readingArray = new Array();		}				/** Select Tag		  * looks to see if anything is on the reader and returns a result pretty instantly		  */		public function selectTag():void{			//			writeByte(0xff);			writeByte(0x00);			writeByte(0x01);			writeByte(0x83);			writeByte(0x84);			//			_readingArray = new Array();		}		/** Seek for Tag		  * starts the 'waiting for a tag' process.		  * As soon as a tag is seen it returns and turns itself off again		  * (so this needs to be called after each return)		  */		public function seekForTag(){						writeByte(0xff);			writeByte(0x00);			writeByte(0x01);			writeByte(0x82);			writeByte(0x83);						_readingArray = new Array();					}				//---------------------------------------		//	PRIVATE FUNCTIONS		//---------------------------------------		private function socketDataHandler(event:ProgressEvent):void {        	while (bytesAvailable>0)				processData(readByte());    	}		/** processes incoming socket data and does something useful with it.		  *		  */		private function processData (inputData:int):void {			var in2:int = inputData;			if (inputData < 0){				in2 = inputData + 256;			}			trace("processData '" + inputData + "' '" + inputData.toString(16) + "' '" + in2 + "' '" + in2.toString(16) + "'");						_readingArray.push( in2.toString(16) );						var trace_str:String = _readingArray.join( ", " );			trace( "processData = " + trace_str + " (" + _readingArray.length + ")" );						if (_readingArray.length >= 3){				var lngth = parseInt(_readingArray[2],16)+4;				if (_readingArray.length >= lngth){					trace_str = _readingArray.join( " " );					var msg_id:String = _readingArray[3];					var mType:String = _readingArray[4];					if (msg_id == "82"){						// it's a seek for tag response!						var message_name:String = "seekForTag";						var message_type:String = "tag";						var tag_type = "";						getTagType(mType);						if (message_type == "tag"){							var tag_str = "";							for(var i=_readingArray.length-2;i>=5;i--){								tag_str += _readingArray[i];							}							dispatchEvent( new RFIDEvent(RFIDEvent.TAG_RESPONSE, tag_str,parseInt(mType,16),tag_type) );						} else {							trace("seekForTag - message was success!");						}					} else if (msg_id == "83"){						// it's a select tag response						var message_name = "selectTag";						var message_type = "tag";						switch( mType ){														case "4c" :								// 'L' command in progress								message_type = "success";								break;							case "55" :								// 'U' command in progress but RF Field is OFF								message_type = "success";								break;						}						trace("message is '" + message_name + "' value='" + trace_str + "'");						if (message_type == "tag"){							var tag_str = "";							for(var i=_readingArray.length-2;i>=5;i--){								tag_str += _readingArray[i];							}							dispatchEvent( new RFIDEvent(RFIDEvent.TAG_RESPONSE, tag_str,parseInt(mType,16),tag_type) );						} else {							trace("selectTag - message was success!");							// this should probably dispatch a failed event of some kind (?)						}					}															_readingArray = new Array();									}			}								}						function getTagType( mtype:String ):String{			var tag_type:String;			switch(mtype){							case "1" :								// type is Milfare Ultralight								tag_type = "Milfare Ultralight";								break;							case "2" :								// type is Milfare Standard 1								tag_type = "Milfare Standard 1";								break;							case "3" :								// type is Milfare Classic 4K								tag_type = "Milfare Classic 4K";								break;							case "ff" :								// type is unknown!								tag_type = "unknown";								break;						}			return tag_type;		}	}}